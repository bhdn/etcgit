#!/usr/bin/python
# 
# Will add untracked files and commit the changed ones. It will try to
# group the commits by package.
#
import sys
import os
import commands
import rpm

class Orphan: pass

def cmd(cmd, noerror=False):
    status, output = commands.getstatusoutput(cmd)
    if status != 0 and not noerror: # argh!
        raise Exception, "%s failed: %s" % (cmd, output)
    return output

def rpmqf(path):
    ts = rpm.ts()
    found = list(ts.dbMatch("basenames", path))
    if found:
        return found[0]["name"]

def changes():
    cmd = "git-ls-files --deleted --modified --others --directory " \
          "--exclude-per-directory=.gitignore"
    io = os.popen(cmd)
    for path in io:
        path = path.rstrip()
        if path:
            yield path
    io.close()

def pkgchanges():
    pkgs = {}
    for path in changes():
        abspath = os.path.abspath(path)
        pkgname = rpmqf(abspath)
        rpmnew = ".rpmnew"
        if pkgname is None and path.endswith(rpmnew):
            orig = abspath[:-len(rpmnew)]
            if os.path.exists(orig):
                pkgname = rpmqf(orig)
        pkgname = pkgname or Orphan
        pkgs.setdefault(pkgname, []).append(path)
    return pkgs

def logmsg(msg):
    return "auto-commit: %s" % msg

def scm(arg):
    return cmd("git %s" % arg)

def fixtree(path):
    "git 'as a content tracker' does not handle empty dirs"
    dirt = False
    for subname in os.listdir(path):
        subpath = os.path.join(path, subname)
        if os.path.isdir(subpath):
            for found in fixtree(subpath):
                yield found
            else:
                # this subtree contains a valid file
                dirt = True
        else:
            break
    else:
        if not dirt:
            dummy = os.path.join(path, ".was-empty")
            open(dummy, "w+").close()
            yield dummy

def add(paths):
    for path in paths[:]:
        # handle empty directories
        if os.path.isdir(path):
            found = list(fixtree(path))
            paths.extend(found)
    arg = " ".join(paths)
    return scm("add %s" % arg)

def commit(paths, msg):
    msg = logmsg(msg)
    arg = " ".join(paths)
    return scm("commit -m \"%s\" %s" % (msg, arg))

def commitpkgs():
    changes = pkgchanges()
    orphan = changes.pop(Orphan, None)
    if orphan:
        add(orphan)
        commit(orphan, "orphan-files")
    for pkg, paths in pkgchanges().iteritems():
        add(paths)
        commit(paths, "owned-by-package: %s" % pkg)

if __name__ == "__main__":
    os.environ["GIT_AUTHOR_NAME"] = "autocommit bot"
    os.chdir("/etc")
    commitpkgs()

# vim:ts=4:sw=4:et
